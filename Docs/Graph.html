<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Graph</title>
        </head><body>
        <h1>Graph</h1>
        <!-- Generated by Ddoc from Graph.d -->
<br><br>
<dl><dt><big><a name="Graph"></a>class <u>Graph</u>;
</big></dt>
<dd><b>Author:</b><br>
Harry Allen
<br><br>
<b>Date:</b><br>
September 20, 2014
<br><br>

 A general graph data structure using an adjacency matrix to store the value of edges.<br><br>

<dl><dt><big><a name="Graph.this"></a> this();
</big></dt>
<dd>Empty constructor.<br><br>

</dd>
<dt><big><a name="Graph.this"></a> this(int <i>maxVertices</i>);
</big></dt>
<dd>Constructor accepting the max number of vertices allowed.<br><br>

</dd>
<dt><big><a name="Graph.getNumItems"></a>int <u>getNumItems</u>();
</big></dt>
<dd><b>Returns:</b><br>
Number of vertices currently in graph<br><br>

</dd>
<dt><big><a name="Graph.getMaxVertices"></a>int <u>getMaxVertices</u>();
</big></dt>
<dd><b>Returns:</b><br>
Maximum number of vertices allowed<br><br>

</dd>
<dt><big><a name="Graph.getVertex"></a>string <u>getVertex</u>(int <i>index</i>);
</big></dt>
<dd><b>Returns:</b><br>
Key of the vertex specified by the parameter.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>index</i></td>
<td>the desired vertex key</td></tr>
</table><br>

</dd>
<dt><big><a name="Graph.getVertices"></a>Vertex[] <u>getVertices</u>();
</big></dt>
<dd><b>Returns:</b><br>
The array of all vertices.<br><br>

</dd>
<dt><big><a name="Graph.getMatrix"></a>string <u>getMatrix</u>();
</big></dt>
<dd><b>Returns:</b><br>
A string representation of the adjacency matrix with
  rows and columns labeled by index.<br><br>

</dd>
<dt><big><a name="Graph.addVertex"></a>void <u>addVertex</u>(string <i>V</i>);
</big></dt>
<dd>Adds a vertex with the given key to the graph.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>V</i></td>
<td>the key for the new vertex</td></tr>
</table><br>

</dd>
<dt><big><a name="Graph.addVertex"></a>void <u>addVertex</u>(Vertex <i>V</i>);
</big></dt>
<dd>Adds the given vertex to the graph.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vertex <i>V</i></td>
<td>the vertex to be added to the graph</td></tr>
</table><br>

</dd>
<dt><big><a name="Graph.addEdge"></a>void <u>addEdge</u>(string <i>startvertex</i>, string <i>endvertex</i>, int <i>edgeweight</i>);
</big></dt>
<dd>Adds an edge to the graph.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>startvertex</i></td>
<td>the key of the vertex from which the edge begins</td></tr>
<tr><td>string <i>endvertex</i></td>
<td>the key of the vertex at which the edge ends</td></tr>
<tr><td>int <i>edgeweight</i></td>
<td>the weight of the edge represented as an integer</td></tr>
</table><br>

</dd>
<dt><big><a name="Graph.geneticAlgorithm"></a>void <u>geneticAlgorithm</u>(int <i>maxpopulationsize</i>, int <i>generations</i>, ref int[][] <i>population</i>, ref double[] <i>fitness</i>);
</big></dt>
<dd>The genetic algorithm which initializes the <i>population</i> with random possible solutions,
 then iterates through each generation by preserving the best 10 solutions and using
 the remaining paths as parents for crossover which will fill the remaining positions
 in the next generation.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>maxpopulationsize</i></td>
<td>the number of paths generated for each <i>population</i></td></tr>
<tr><td>int <i>generations</i></td>
<td>the number of <i>generations</i> to iterate through</td></tr>
<tr><td>int[][] <i>population</i></td>
<td>2 dimensional array to store each generation's <i>population</i></td></tr>
<tr><td>double[] <i>fitness</i></td>
<td>array of the <i>fitness</i> values for each possible solution</td></tr>
</table><br>

</dd>
<dt><big><a name="Graph.calculateFitness"></a>double[] <u>calculateFitness</u>(int[][] <i>population</i>);
</big></dt>
<dd>Calculates the fitness values for all paths in a <i>population</i> from the edge weights between each vertex.
<br><br>
<b>Params:</b><br>
<table><tr><td>int[][] <i>population</i></td>
<td>the <i>population</i> to generate the fitness values for</td></tr>
</table><br>
<b>Returns:</b><br>
The list of fitness values represented as an array of doubles<br><br>

</dd>
<dt><big><a name="Graph.insertionSort"></a>void <u>insertionSort</u>(ref int[][] <i>population</i>, ref double[] <i>fitness</i>);
</big></dt>
<dd>Insertion Sort algorithm which sorts the given <i>population</i> along with the its <i>fitness</i> values.
<br><br>
<b>Params:</b><br>
<table><tr><td>int[][] <i>population</i></td>
<td>the <i>population</i> to sort</td></tr>
<tr><td>double[] <i>fitness</i></td>
<td>the poulation's corresponding <i>fitness</i> values which will also be sorted</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
